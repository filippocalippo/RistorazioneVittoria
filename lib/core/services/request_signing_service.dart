import 'dart:convert';
import 'dart:typed_data';
import 'dart:math' as math;
import 'package:crypto/crypto.dart';
import '../utils/logger.dart';

/// Request Signing Service
///
/// Provides HMAC-based request signing to prevent replay attacks
/// and ensure request integrity for edge function calls.
///
/// Part of Section 8.2 Backend Production Readiness
class RequestSigningService {
  /// Signs a request body with the organization's secret
  ///
  /// The signature is computed as HMAC-SHA256 of the JSON-serialized payload
  /// including timestamp and nonce.
  ///
  /// Parameters:
  /// - [body]: The request payload (will be serialized to JSON)
  /// - [secret]: The organization's signing secret (from organizations.request_signing_secret)
  /// - [timestamp]: ISO 8601 timestamp string (generated by this method if not provided)
  /// - [nonce]: Unique value for this request (generated by this method if not provided)
  ///
  /// Returns a map with the signature components to add to the request body
  static Map<String, dynamic> signRequest({
    required Map<String, dynamic> body,
    required String secret,
    String? timestamp,
    String? nonce,
  }) {
    // Generate timestamp if not provided
    timestamp ??= DateTime.now().toIso8601String();

    // Generate nonce if not provided
    nonce ??= _generateNonce();

    // Create the payload to sign
    // Important: We don't include the signature in the signed payload
    final payload = {
      ...body,
      'timestamp': timestamp,
      'nonce': nonce,
    };

    // Serialize to JSON (sorted keys for consistency)
    final jsonString = _canonicalJson(payload);

    // Compute HMAC-SHA256
    final hmac = Hmac(sha256, secret.codeUnits);
    final digest = hmac.convert(jsonString.codeUnits);

    // Return signature components
    return {
      ...body,
      'timestamp': timestamp,
      'nonce': nonce,
      'signature': digest.toString(),
    };
  }

  /// Verifies a response signature from the server
  ///
  /// This can be used to verify responses from edge functions
  /// if they implement response signing.
  ///
  /// Parameters:
  /// - [responseBody]: The response body
  /// - [secret]: The organization's signing secret
  ///
  /// Returns true if the signature is valid
  static bool verifyResponse({
    required Map<String, dynamic> responseBody,
    required String secret,
  }) {
    final signature = responseBody['signature'] as String?;
    final timestamp = responseBody['timestamp'] as String?;
    final nonce = responseBody['nonce'] as String?;

    if (signature == null || timestamp == null || nonce == null) {
      Logger.warning('Response missing signature fields', tag: 'RequestSigning');
      return false;
    }

    // Recreate the payload
    final payload = {
      ...responseBody,
      'timestamp': timestamp,
      'nonce': nonce,
    };
    payload.remove('signature'); // Don't include signature in verification

    // Compute expected signature
    final jsonString = _canonicalJson(payload);
    final hmac = Hmac(sha256, secret.codeUnits);
    final digest = hmac.convert(jsonString.codeUnits);
    final expectedSignature = digest.toString();

    // Compare signatures
    return signature == expectedSignature;
  }

  /// Generates a unique nonce for request signing
  ///
  /// The nonce combines:
  /// - Current timestamp in base36 (for uniqueness)
  /// - Random bytes for additional entropy
  static String _generateNonce() {
    final timestamp = DateTime.now().millisecondsSinceEpoch.toRadixString(36);

    // Generate 16 random bytes (128 bits)
    final random = _secureRandom(16);

    // Convert to hex string
    final randomStr = random.map((b) => b.toRadixString(16).padLeft(2, '0')).join('');

    return '$timestamp-$randomStr';
  }

  /// Generates cryptographically secure random bytes
  static Uint8List _secureRandom(int length) {
    final bytes = Uint8List(length);
    final random = math.Random.secure();
    // Use crypto package's random number generator
    for (int i = 0; i < length; i++) {
      bytes[i] = random.nextInt(256);
    }
    return bytes;
  }

  /// Creates a canonical JSON string for signing
  ///
  /// Keys are sorted alphabetically to ensure consistent
  /// serialization regardless of Map implementation.
  static String _canonicalJson(Map<String, dynamic> obj) {
    // Sort keys
    final sortedKeys = obj.keys.toList()..sort();

    // Build JSON string manually for consistency
    final buffer = StringBuffer();
    buffer.write('{');

    for (int i = 0; i < sortedKeys.length; i++) {
      if (i > 0) buffer.write(',');
      final key = sortedKeys[i];
      final value = obj[key];

      buffer.write('"$key":');
      buffer.write(_jsonEncode(value));
    }

    buffer.write('}');
    return buffer.toString();
  }

  /// Encodes a value to JSON (handles nested structures)
  static String _jsonEncode(dynamic value) {
    if (value == null) {
      return 'null';
    } else if (value is String) {
      return jsonEncode(value);
    } else if (value is num || value is bool) {
      return value.toString();
    } else if (value is Map) {
      return _canonicalJson(Map<String, dynamic>.from(value));
    } else if (value is List) {
      final items = value.map((v) => _jsonEncode(v)).join(',');
      return '[$items]';
    } else {
      // Fallback to standard encoding
      return jsonEncode(value);
    }
  }

  /// Validates a timestamp is within the allowed window
  ///
  /// Parameters:
  /// - [timestamp]: ISO 8601 timestamp string
  /// - [windowSeconds]: Allowed time window in seconds (default: 300 = 5 minutes)
  ///
  /// Returns true if timestamp is within the window
  static bool isTimestampValid(String timestamp, {int windowSeconds = 300}) {
    try {
      final requestTime = DateTime.parse(timestamp);
      final now = DateTime.now();
      final difference = now.difference(requestTime).abs();

      return difference.inSeconds <= windowSeconds;
    } catch (e) {
      Logger.error('Invalid timestamp format: $timestamp', tag: 'RequestSigning');
      return false;
    }
  }
}
